{"ast":null,"code":"/**\n * @module ol/render/canvas/ZIndexContext\n */\n\nimport { getSharedCanvasContext2D } from '../../dom.js';\n\n/** @typedef {CanvasRenderingContext2D & {globalAlpha: any}} ZIndexContextProxy */\n\n/**\n * @extends {CanvasRenderingContext2D}\n */\nclass ZIndexContext {\n  constructor() {\n    /**\n     * @private\n     * @type {Array<Array<*>>}\n     */\n    this.instructions_ = [];\n    /**\n     * @type {number}\n     */\n    this.zIndex = 0;\n    /**\n     * @private\n     * @type {number}\n     */\n    this.offset_ = 0;\n\n    /**\n     * @type {ZIndexContextProxy}\n     */\n    this.context_ = /** @type {ZIndexContextProxy} */\n    new Proxy(CanvasRenderingContext2D.prototype, {\n      get: (target, property) => {\n        if (typeof ( /** @type {*} */getSharedCanvasContext2D()[property]) !== 'function') {\n          // we only accept calling functions on the proxy, not accessing properties\n          return undefined;\n        }\n        if (!this.instructions_[this.zIndex + this.offset_]) {\n          this.instructions_[this.zIndex + this.offset_] = [];\n        }\n        this.instructions_[this.zIndex + this.offset_].push(property);\n        return this.pushMethodArgs_;\n      },\n      set: (target, property, value) => {\n        if (!this.instructions_[this.zIndex + this.offset_]) {\n          this.instructions_[this.zIndex + this.offset_] = [];\n        }\n        this.instructions_[this.zIndex + this.offset_].push(property, value);\n        return true;\n      }\n    });\n  }\n\n  /**\n   * @private\n   * @param {...*} args Args.\n   * @return {ZIndexContext} This.\n   */\n  pushMethodArgs_ = (...args) => {\n    this.instructions_[this.zIndex + this.offset_].push(args);\n    return this;\n  };\n\n  /**\n   * Get a proxy for CanvasRenderingContext2D which does not support getting state\n   * (e.g. `context.globalAlpha`, which will return `undefined`). To set state, if it relies on a\n   * previous state (e.g. `context.globalAlpha = context.globalAlpha / 2`), set a function,\n   * e.g. `context.globalAlpha = (context) => context.globalAlpha / 2`.\n   * @return {ZIndexContextProxy} Context.\n   */\n  getContext() {\n    return this.context_;\n  }\n\n  /**\n   * @param {CanvasRenderingContext2D} context Context.\n   */\n  draw(context) {\n    this.instructions_.forEach(instructionsAtIndex => {\n      for (let i = 0, ii = instructionsAtIndex.length; i < ii; i += 2) {\n        const property = instructionsAtIndex[i];\n        const instructionAtIndex = instructionsAtIndex[i + 1];\n        if (typeof ( /** @type {*} */context[property]) === 'function') {\n          /** @type {*} */context[property](...instructionAtIndex);\n        } else {\n          if (typeof instructionAtIndex === 'function') {\n            /** @type {*} */context[property] = instructionAtIndex(context);\n            continue;\n          }\n          /** @type {*} */\n          context[property] = instructionAtIndex;\n        }\n      }\n    });\n  }\n  clear() {\n    this.instructions_.length = 0;\n    this.zIndex = 0;\n    this.offset_ = 0;\n  }\n\n  /**\n   * Offsets the zIndex by the highest current zIndex. Useful for rendering multiple worlds or tiles, to\n   * avoid conflicting context.clip() or context.save()/restore() calls.\n   */\n  offset() {\n    this.offset_ = this.instructions_.length;\n    this.zIndex = 0;\n  }\n}\nexport default ZIndexContext;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}