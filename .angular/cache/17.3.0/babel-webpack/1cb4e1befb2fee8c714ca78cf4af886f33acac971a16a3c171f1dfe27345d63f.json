{"ast":null,"code":"/**\n * @module ol/webgl/TileTexture\n */\n\nimport BaseTileRepresentation from './BaseTileRepresentation.js';\nimport DataTile, { asArrayLike, asImageLike } from '../DataTile.js';\nimport EventType from '../events/EventType.js';\nimport ImageTile from '../ImageTile.js';\nimport ReprojTile from '../reproj/Tile.js';\nimport WebGLArrayBuffer from './Buffer.js';\nimport { ARRAY_BUFFER, STATIC_DRAW } from '../webgl.js';\nimport { createCanvasContext2D } from '../dom.js';\nimport { toSize } from '../size.js';\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction bindAndConfigure(gl, texture, interpolate) {\n  const resampleFilter = interpolate ? gl.LINEAR : gl.NEAREST;\n  gl.bindTexture(gl.TEXTURE_2D, texture);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, resampleFilter);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, resampleFilter);\n}\n\n/**\n * @param {WebGLRenderingContext} gl The WebGL context.\n * @param {WebGLTexture} texture The texture.\n * @param {import(\"../DataTile.js\").ImageLike} image The image.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadImageTexture(gl, texture, image, interpolate) {\n  bindAndConfigure(gl, texture, interpolate);\n  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n}\n\n/**\n * @param {import(\"./Helper.js\").default} helper The WebGL helper.\n * @param {WebGLTexture} texture The texture.\n * @param {import(\"../DataTile.js\").ArrayLike} data The pixel data.\n * @param {import(\"../size.js\").Size} size The pixel size.\n * @param {number} bandCount The band count.\n * @param {boolean} interpolate Interpolate when resampling.\n */\nfunction uploadDataTexture(helper, texture, data, size, bandCount, interpolate) {\n  const gl = helper.getGL();\n  let textureType;\n  let canInterpolate;\n  if (data instanceof Float32Array) {\n    textureType = gl.FLOAT;\n    helper.getExtension('OES_texture_float');\n    const extension = helper.getExtension('OES_texture_float_linear');\n    canInterpolate = extension !== null;\n  } else {\n    textureType = gl.UNSIGNED_BYTE;\n    canInterpolate = true;\n  }\n  bindAndConfigure(gl, texture, interpolate && canInterpolate);\n  const bytesPerRow = data.byteLength / size[1];\n  let unpackAlignment = 1;\n  if (bytesPerRow % 8 === 0) {\n    unpackAlignment = 8;\n  } else if (bytesPerRow % 4 === 0) {\n    unpackAlignment = 4;\n  } else if (bytesPerRow % 2 === 0) {\n    unpackAlignment = 2;\n  }\n  let format;\n  switch (bandCount) {\n    case 1:\n      {\n        format = gl.LUMINANCE;\n        break;\n      }\n    case 2:\n      {\n        format = gl.LUMINANCE_ALPHA;\n        break;\n      }\n    case 3:\n      {\n        format = gl.RGB;\n        break;\n      }\n    case 4:\n      {\n        format = gl.RGBA;\n        break;\n      }\n    default:\n      {\n        throw new Error(`Unsupported number of bands: ${bandCount}`);\n      }\n  }\n  const oldUnpackAlignment = gl.getParameter(gl.UNPACK_ALIGNMENT);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, unpackAlignment);\n  gl.texImage2D(gl.TEXTURE_2D, 0, format, size[0], size[1], 0, format, textureType, data);\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, oldUnpackAlignment);\n}\n\n/**\n * @type {CanvasRenderingContext2D}\n */\nlet pixelContext = null;\nfunction createPixelContext() {\n  pixelContext = createCanvasContext2D(1, 1, undefined, {\n    willReadFrequently: true\n  });\n}\n\n/**\n * @typedef {import(\"../DataTile.js\").default|ImageTile|ReprojTile} TileType\n */\n\n/**\n * @extends {BaseTileRepresentation<TileType>}\n */\nclass TileTexture extends BaseTileRepresentation {\n  /**\n   * @param {import(\"./BaseTileRepresentation.js\").TileRepresentationOptions<TileType>} options The tile texture options.\n   */\n  constructor(options) {\n    super(options);\n\n    /**\n     * @type {Array<WebGLTexture>}\n     */\n    this.textures = [];\n\n    /**\n     * @type {import(\"../size.js\").Size}\n     * @private\n     */\n    this.renderSize_ = toSize(options.grid.getTileSize(options.tile.tileCoord[0]));\n\n    /**\n     * @type {number}\n     */\n    this.bandCount = NaN;\n    const coords = new WebGLArrayBuffer(ARRAY_BUFFER, STATIC_DRAW);\n    coords.fromArray([0,\n    // P0\n    1, 1,\n    // P1\n    1, 1,\n    // P2\n    0, 0,\n    // P3\n    0]);\n    this.helper_.flushBufferData(coords);\n\n    /**\n     * @type {WebGLArrayBuffer}\n     */\n    this.coords = coords;\n    this.setTile(options.tile);\n  }\n  uploadTile() {\n    const helper = this.helper_;\n    const gl = helper.getGL();\n    const tile = this.tile;\n    this.textures.length = 0;\n\n    /**\n     * @type {import(\"../DataTile.js\").Data}\n     */\n    let data;\n    if (tile instanceof ImageTile || tile instanceof ReprojTile) {\n      data = tile.getImage();\n    } else {\n      data = tile.getData();\n    }\n    const image = asImageLike(data);\n    if (image) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      this.bandCount = 4;\n      uploadImageTexture(gl, texture, image, tile.interpolate);\n      this.setReady();\n      return;\n    }\n    data = asArrayLike(data);\n    const sourceTileSize = /** @type {DataTile} */tile.getSize();\n    const pixelSize = [sourceTileSize[0] + 2 * this.gutter_, sourceTileSize[1] + 2 * this.gutter_];\n    const isFloat = data instanceof Float32Array;\n    const pixelCount = pixelSize[0] * pixelSize[1];\n    const DataType = isFloat ? Float32Array : Uint8Array;\n    const bytesPerElement = DataType.BYTES_PER_ELEMENT;\n    const bytesPerRow = data.byteLength / pixelSize[1];\n    this.bandCount = Math.floor(bytesPerRow / bytesPerElement / pixelSize[0]);\n    const textureCount = Math.ceil(this.bandCount / 4);\n    if (textureCount === 1) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      uploadDataTexture(helper, texture, data, pixelSize, this.bandCount, tile.interpolate);\n      this.setReady();\n      return;\n    }\n    const textureDataArrays = new Array(textureCount);\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = gl.createTexture();\n      this.textures.push(texture);\n      const bandCount = textureIndex < textureCount - 1 ? 4 : (this.bandCount - 1) % 4 + 1;\n      textureDataArrays[textureIndex] = new DataType(pixelCount * bandCount);\n    }\n    let dataIndex = 0;\n    let rowOffset = 0;\n    const colCount = pixelSize[0] * this.bandCount;\n    for (let rowIndex = 0; rowIndex < pixelSize[1]; ++rowIndex) {\n      for (let colIndex = 0; colIndex < colCount; ++colIndex) {\n        const dataValue = data[rowOffset + colIndex];\n        const pixelIndex = Math.floor(dataIndex / this.bandCount);\n        const bandIndex = colIndex % this.bandCount;\n        const textureIndex = Math.floor(bandIndex / 4);\n        const textureData = textureDataArrays[textureIndex];\n        const bandCount = textureData.length / pixelCount;\n        const textureBandIndex = bandIndex % 4;\n        textureData[pixelIndex * bandCount + textureBandIndex] = dataValue;\n        ++dataIndex;\n      }\n      rowOffset += bytesPerRow / bytesPerElement;\n    }\n    for (let textureIndex = 0; textureIndex < textureCount; ++textureIndex) {\n      const texture = this.textures[textureIndex];\n      const textureData = textureDataArrays[textureIndex];\n      const bandCount = textureData.length / pixelCount;\n      uploadDataTexture(helper, texture, textureData, pixelSize, bandCount, tile.interpolate);\n    }\n    this.setReady();\n  }\n  disposeInternal() {\n    const gl = this.helper_.getGL();\n    this.helper_.deleteBuffer(this.coords);\n    for (let i = 0; i < this.textures.length; ++i) {\n      gl.deleteTexture(this.textures[i]);\n    }\n    this.tile.removeEventListener(EventType.CHANGE, this.handleTileChange_);\n  }\n\n  /**\n   * @param {import(\"../DataTile.js\").ImageLike} image The image.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {Uint8ClampedArray|null} The data.\n   * @private\n   */\n  getImagePixelData_(image, renderCol, renderRow) {\n    const gutter = this.gutter_;\n    const renderWidth = this.renderSize_[0];\n    const renderHeight = this.renderSize_[1];\n    if (!pixelContext) {\n      createPixelContext();\n    }\n    pixelContext.clearRect(0, 0, 1, 1);\n    const sourceWidth = image.width;\n    const sourceHeight = image.height;\n    const sourceWidthWithoutGutter = sourceWidth - 2 * gutter;\n    const sourceHeightWithoutGutter = sourceHeight - 2 * gutter;\n    const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n    const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n    let data;\n    try {\n      pixelContext.drawImage(image, sourceCol, sourceRow, 1, 1, 0, 0, 1, 1);\n      data = pixelContext.getImageData(0, 0, 1, 1).data;\n    } catch (err) {\n      pixelContext = null;\n      return null;\n    }\n    return data;\n  }\n\n  /**\n   * @param {import(\"../DataTile.js\").ArrayLike} data The data.\n   * @param {import(\"../size.js\").Size} sourceSize The size.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\n   * @private\n   */\n  getArrayPixelData_(data, sourceSize, renderCol, renderRow) {\n    const gutter = this.gutter_;\n    const renderWidth = this.renderSize_[0];\n    const renderHeight = this.renderSize_[1];\n    const sourceWidthWithoutGutter = sourceSize[0];\n    const sourceHeightWithoutGutter = sourceSize[1];\n    const sourceWidth = sourceWidthWithoutGutter + 2 * gutter;\n    const sourceHeight = sourceHeightWithoutGutter + 2 * gutter;\n    const sourceCol = gutter + Math.floor(sourceWidthWithoutGutter * (renderCol / renderWidth));\n    const sourceRow = gutter + Math.floor(sourceHeightWithoutGutter * (renderRow / renderHeight));\n    if (data instanceof DataView) {\n      const bytesPerPixel = data.byteLength / (sourceWidth * sourceHeight);\n      const offset = bytesPerPixel * (sourceRow * sourceWidth + sourceCol);\n      const buffer = data.buffer.slice(offset, offset + bytesPerPixel);\n      return new DataView(buffer);\n    }\n    const offset = this.bandCount * (sourceRow * sourceWidth + sourceCol);\n    return data.slice(offset, offset + this.bandCount);\n  }\n\n  /**\n   * Get data for a pixel.  If the tile is not loaded, null is returned.\n   * @param {number} renderCol The column index (in rendered tile space).\n   * @param {number} renderRow The row index (in rendered tile space).\n   * @return {import(\"../DataTile.js\").ArrayLike|null} The data.\n   */\n  getPixelData(renderCol, renderRow) {\n    if (!this.loaded) {\n      return null;\n    }\n    if (this.tile instanceof DataTile) {\n      const data = this.tile.getData();\n      const arrayData = asArrayLike(data);\n      if (arrayData) {\n        const sourceSize = this.tile.getSize();\n        return this.getArrayPixelData_(arrayData, sourceSize, renderCol, renderRow);\n      }\n      return this.getImagePixelData_(asImageLike(data), renderCol, renderRow);\n    }\n    return this.getImagePixelData_(this.tile.getImage(), renderCol, renderRow);\n  }\n}\nexport default TileTexture;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}