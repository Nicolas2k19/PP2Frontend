{"ast":null,"code":"/**\n * @module ol/webgl/PostProcessingPass\n */\n\nimport { getUid } from '../util.js';\nconst DEFAULT_VERTEX_SHADER = `\n  precision mediump float;\n  \n  attribute vec2 a_position;\n  varying vec2 v_texCoord;\n  varying vec2 v_screenCoord;\n  \n  uniform vec2 u_screenSize;\n   \n  void main() {\n    v_texCoord = a_position * 0.5 + 0.5;\n    v_screenCoord = v_texCoord * u_screenSize;\n    gl_Position = vec4(a_position, 0.0, 1.0);\n  }\n`;\nconst DEFAULT_FRAGMENT_SHADER = `\n  precision mediump float;\n   \n  uniform sampler2D u_image;\n  uniform float u_opacity;\n   \n  varying vec2 v_texCoord;\n   \n  void main() {\n    gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n  }\n`;\n\n/**\n * @typedef {Object} Options\n * @property {WebGLRenderingContext} webGlContext WebGL context; mandatory.\n * @property {number} [scaleRatio] Scale ratio; if < 1, the post process will render to a texture smaller than\n * the main canvas that will then be sampled up (useful for saving resource on blur steps).\n * @property {string} [vertexShader] Vertex shader source\n * @property {string} [fragmentShader] Fragment shader source\n * @property {Object<string,import(\"./Helper\").UniformValue>} [uniforms] Uniform definitions for the post process step\n */\n\n/**\n * @typedef {Object} UniformInternalDescription\n * @property {import(\"./Helper\").UniformValue} value Value\n * @property {WebGLUniformLocation} location Location\n * @property {WebGLTexture} [texture] Texture\n * @private\n */\n\n/**\n * @classdesc\n * This class is used to define Post Processing passes with custom shaders and uniforms.\n * This is used internally by {@link module:ol/webgl/Helper~WebGLHelper}.\n *\n * Please note that the final output on the DOM canvas is expected to have premultiplied alpha, which means that\n * a pixel which is 100% red with an opacity of 50% must have a color of (r=0.5, g=0, b=0, a=0.5).\n * Failing to provide pixel colors with premultiplied alpha will result in render anomalies.\n *\n * The default post-processing pass does *not* multiply color values with alpha value, it expects color values to be\n * premultiplied.\n *\n * Default shaders are shown hereafter:\n *\n * * Vertex shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   attribute vec2 a_position;\n *   varying vec2 v_texCoord;\n *   varying vec2 v_screenCoord;\n *\n *   uniform vec2 u_screenSize;\n *\n *   void main() {\n *     v_texCoord = a_position * 0.5 + 0.5;\n *     v_screenCoord = v_texCoord * u_screenSize;\n *     gl_Position = vec4(a_position, 0.0, 1.0);\n *   }\n *   ```\n *\n * * Fragment shader:\n *\n *   ```\n *   precision mediump float;\n *\n *   uniform sampler2D u_image;\n *   uniform float u_opacity;\n *\n *   varying vec2 v_texCoord;\n *\n *   void main() {\n *     gl_FragColor = texture2D(u_image, v_texCoord) * u_opacity;\n *   }\n *   ```\n */\nclass WebGLPostProcessingPass {\n  /**\n   * @param {Options} options Options.\n   */\n  constructor(options) {\n    this.gl_ = options.webGlContext;\n    const gl = this.gl_;\n    this.scaleRatio_ = options.scaleRatio || 1;\n    this.renderTargetTexture_ = gl.createTexture();\n    this.renderTargetTextureSize_ = null;\n    this.frameBuffer_ = gl.createFramebuffer();\n    this.depthBuffer_ = gl.createRenderbuffer();\n\n    // compile the program for the frame buffer\n    // TODO: make compilation errors show up\n    const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n    gl.shaderSource(vertexShader, options.vertexShader || DEFAULT_VERTEX_SHADER);\n    gl.compileShader(vertexShader);\n    const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n    gl.shaderSource(fragmentShader, options.fragmentShader || DEFAULT_FRAGMENT_SHADER);\n    gl.compileShader(fragmentShader);\n    this.renderTargetProgram_ = gl.createProgram();\n    gl.attachShader(this.renderTargetProgram_, vertexShader);\n    gl.attachShader(this.renderTargetProgram_, fragmentShader);\n    gl.linkProgram(this.renderTargetProgram_);\n\n    // bind the vertices buffer for the frame buffer\n    this.renderTargetVerticesBuffer_ = gl.createBuffer();\n    const verticesArray = [-1, -1, 1, -1, -1, 1, 1, -1, 1, 1, -1, 1];\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(verticesArray), gl.STATIC_DRAW);\n    this.renderTargetAttribLocation_ = gl.getAttribLocation(this.renderTargetProgram_, 'a_position');\n    this.renderTargetUniformLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_screenSize');\n    this.renderTargetOpacityLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_opacity');\n    this.renderTargetTextureLocation_ = gl.getUniformLocation(this.renderTargetProgram_, 'u_image');\n\n    /**\n     * Holds info about custom uniforms used in the post processing pass\n     * @type {Array<UniformInternalDescription>}\n     * @private\n     */\n    this.uniforms_ = [];\n    options.uniforms && Object.keys(options.uniforms).forEach(name => {\n      this.uniforms_.push({\n        value: options.uniforms[name],\n        location: gl.getUniformLocation(this.renderTargetProgram_, name)\n      });\n    });\n  }\n\n  /**\n   * Get the WebGL rendering context\n   * @return {WebGLRenderingContext} The rendering context.\n   */\n  getGL() {\n    return this.gl_;\n  }\n\n  /**\n   * Initialize the render target texture of the post process, make sure it is at the\n   * right size and bind it as a render target for the next draw calls.\n   * The last step to be initialized will be the one where the primitives are rendered.\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   */\n  init(frameState) {\n    const gl = this.getGL();\n    const textureSize = [gl.drawingBufferWidth * this.scaleRatio_, gl.drawingBufferHeight * this.scaleRatio_];\n\n    // rendering goes to my buffer\n    gl.bindFramebuffer(gl.FRAMEBUFFER, this.getFrameBuffer());\n    gl.bindRenderbuffer(gl.RENDERBUFFER, this.getDepthBuffer());\n    gl.viewport(0, 0, textureSize[0], textureSize[1]);\n\n    // if size has changed: adjust canvas & render target texture\n    if (!this.renderTargetTextureSize_ || this.renderTargetTextureSize_[0] !== textureSize[0] || this.renderTargetTextureSize_[1] !== textureSize[1]) {\n      this.renderTargetTextureSize_ = textureSize;\n\n      // create a new texture\n      const level = 0;\n      const internalFormat = gl.RGBA;\n      const border = 0;\n      const format = gl.RGBA;\n      const type = gl.UNSIGNED_BYTE;\n      const data = null;\n      gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n      gl.texImage2D(gl.TEXTURE_2D, level, internalFormat, textureSize[0], textureSize[1], border, format, type, data);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n\n      // bind the texture to the framebuffer\n      gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, this.renderTargetTexture_, 0);\n      gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_COMPONENT16, textureSize[0], textureSize[1]);\n      gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, this.depthBuffer_);\n    }\n  }\n\n  /**\n   * Render to the next postprocessing pass (or to the canvas if final pass).\n   * @param {import(\"../Map.js\").FrameState} frameState current frame state\n   * @param {WebGLPostProcessingPass} [nextPass] Next pass, optional\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [preCompose] Called before composing.\n   * @param {function(WebGLRenderingContext, import(\"../Map.js\").FrameState):void} [postCompose] Called before composing.\n   */\n  apply(frameState, nextPass, preCompose, postCompose) {\n    const gl = this.getGL();\n    const size = frameState.size;\n    gl.bindFramebuffer(gl.FRAMEBUFFER, nextPass ? nextPass.getFrameBuffer() : null);\n    gl.activeTexture(gl.TEXTURE0);\n    gl.bindTexture(gl.TEXTURE_2D, this.renderTargetTexture_);\n    if (!nextPass) {\n      // clear the canvas if we are the first to render to it\n      // and preserveDrawingBuffer is true\n      const canvasId = getUid(gl.canvas);\n      if (!frameState.renderTargets[canvasId]) {\n        const attributes = gl.getContextAttributes();\n        if (attributes && attributes.preserveDrawingBuffer) {\n          gl.clearColor(0.0, 0.0, 0.0, 0.0);\n          gl.clearDepth(1.0);\n          gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);\n        }\n        frameState.renderTargets[canvasId] = true;\n      }\n    }\n    gl.disable(gl.DEPTH_TEST);\n    gl.enable(gl.BLEND);\n    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);\n    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);\n    gl.bindBuffer(gl.ARRAY_BUFFER, this.renderTargetVerticesBuffer_);\n    gl.useProgram(this.renderTargetProgram_);\n    gl.enableVertexAttribArray(this.renderTargetAttribLocation_);\n    gl.vertexAttribPointer(this.renderTargetAttribLocation_, 2, gl.FLOAT, false, 0, 0);\n    gl.uniform2f(this.renderTargetUniformLocation_, size[0], size[1]);\n    gl.uniform1i(this.renderTargetTextureLocation_, 0);\n    const opacity = frameState.layerStatesArray[frameState.layerIndex].opacity;\n    gl.uniform1f(this.renderTargetOpacityLocation_, opacity);\n    this.applyUniforms(frameState);\n    if (preCompose) {\n      preCompose(gl, frameState);\n    }\n    gl.drawArrays(gl.TRIANGLES, 0, 6);\n    if (postCompose) {\n      postCompose(gl, frameState);\n    }\n  }\n\n  /**\n   * @return {WebGLFramebuffer} Frame buffer\n   */\n  getFrameBuffer() {\n    return this.frameBuffer_;\n  }\n\n  /**\n   * @return {WebGLRenderbuffer} Depth buffer\n   */\n  getDepthBuffer() {\n    return this.depthBuffer_;\n  }\n\n  /**\n   * Sets the custom uniforms based on what was given in the constructor.\n   * @param {import(\"../Map.js\").FrameState} frameState Frame state.\n   * @private\n   */\n  applyUniforms(frameState) {\n    const gl = this.getGL();\n    let value;\n    let textureSlot = 1;\n    this.uniforms_.forEach(function (uniform) {\n      value = typeof uniform.value === 'function' ? uniform.value(frameState) : uniform.value;\n\n      // apply value based on type\n      if (value instanceof HTMLCanvasElement || value instanceof ImageData) {\n        // create a texture & put data\n        if (!uniform.texture) {\n          uniform.texture = gl.createTexture();\n        }\n        gl.activeTexture(gl[`TEXTURE${textureSlot}`]);\n        gl.bindTexture(gl.TEXTURE_2D, uniform.texture);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n        if (value instanceof ImageData) {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, value.width, value.height, 0, gl.UNSIGNED_BYTE, new Uint8Array(value.data));\n        } else {\n          gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, value);\n        }\n\n        // fill texture slots\n        gl.uniform1i(uniform.location, textureSlot++);\n      } else if (Array.isArray(value)) {\n        switch (value.length) {\n          case 2:\n            gl.uniform2f(uniform.location, value[0], value[1]);\n            return;\n          case 3:\n            gl.uniform3f(uniform.location, value[0], value[1], value[2]);\n            return;\n          case 4:\n            gl.uniform4f(uniform.location, value[0], value[1], value[2], value[3]);\n            return;\n          default:\n            return;\n        }\n      } else if (typeof value === 'number') {\n        gl.uniform1f(uniform.location, value);\n      }\n    });\n  }\n}\nexport default WebGLPostProcessingPass;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}