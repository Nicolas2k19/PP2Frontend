{"ast":null,"code":"/**\n * @module ol/expr/cpu\n */\n\nimport { ColorType, LiteralExpression, Ops, overlapsType, parse, typeName } from './expression.js';\nimport { fromString, lchaToRgba, normalize, rgbaToLcha, withAlpha } from '../color.js';\n\n/**\n * @fileoverview This module includes functions to build expressions for evaluation on the CPU.\n * Building is composed of two steps: parsing and compiling.  The parsing step takes an encoded\n * expression and returns an instance of one of the expression classes.  The compiling step takes\n * the expression instance and returns a function that can be evaluated in to return a literal\n * value.  The evaluator function should do as little allocation and work as possible.\n */\n\n/**\n * @typedef {Object} EvaluationContext\n * @property {Object} properties The values for properties used in 'get' expressions.\n * @property {Object} variables The values for variables used in 'var' expressions.\n * @property {number} resolution The map resolution.\n * @property {string|number|null} featureId The feature id.\n * @property {string} geometryType Geometry type of the current object.\n */\n\n/**\n * @return {EvaluationContext} A new evaluation context.\n */\nexport function newEvaluationContext() {\n  return {\n    variables: {},\n    properties: {},\n    resolution: NaN,\n    featureId: null,\n    geometryType: ''\n  };\n}\n\n/**\n * @typedef {function(EvaluationContext):import(\"./expression.js\").LiteralValue} ExpressionEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):boolean} BooleanEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):number} NumberEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):string} StringEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|string)} ColorLikeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} NumberArrayEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):Array<number>} CoordinateEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>)} SizeEvaluator\n */\n\n/**\n * @typedef {function(EvaluationContext):(Array<number>|number)} SizeLikeEvaluator\n */\n\n/**\n * @param {import('./expression.js').EncodedExpression} encoded The encoded expression.\n * @param {number} type The expected type.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The expression evaluator.\n */\nexport function buildExpression(encoded, type, context) {\n  const expression = parse(encoded, context);\n  if (!overlapsType(type, expression.type)) {\n    const expected = typeName(type);\n    const actual = typeName(expression.type);\n    throw new Error(`Expected expression to be of type ${expected}, got ${actual}`);\n  }\n  return compileExpression(expression, context);\n}\n\n/**\n * @param {import(\"./expression.js\").Expression} expression The expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileExpression(expression, context) {\n  if (expression instanceof LiteralExpression) {\n    // convert colors to array if possible\n    if (expression.type === ColorType && typeof expression.value === 'string') {\n      const colorValue = fromString(expression.value);\n      return function () {\n        return colorValue;\n      };\n    }\n    return function () {\n      return expression.value;\n    };\n  }\n  const operator = expression.operator;\n  switch (operator) {\n    case Ops.Number:\n    case Ops.String:\n    case Ops.Coalesce:\n      {\n        return compileAssertionExpression(expression, context);\n      }\n    case Ops.Get:\n    case Ops.Var:\n      {\n        return compileAccessorExpression(expression, context);\n      }\n    case Ops.Id:\n      {\n        return context => context.featureId;\n      }\n    case Ops.GeometryType:\n      {\n        return context => context.geometryType;\n      }\n    case Ops.Concat:\n      {\n        const args = expression.args.map(e => compileExpression(e, context));\n        return context => ''.concat(...args.map(arg => arg(context).toString()));\n      }\n    case Ops.Resolution:\n      {\n        return context => context.resolution;\n      }\n    case Ops.Any:\n    case Ops.All:\n    case Ops.Not:\n      {\n        return compileLogicalExpression(expression, context);\n      }\n    case Ops.Equal:\n    case Ops.NotEqual:\n    case Ops.LessThan:\n    case Ops.LessThanOrEqualTo:\n    case Ops.GreaterThan:\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return compileComparisonExpression(expression, context);\n      }\n    case Ops.Multiply:\n    case Ops.Divide:\n    case Ops.Add:\n    case Ops.Subtract:\n    case Ops.Clamp:\n    case Ops.Mod:\n    case Ops.Pow:\n    case Ops.Abs:\n    case Ops.Floor:\n    case Ops.Ceil:\n    case Ops.Round:\n    case Ops.Sin:\n    case Ops.Cos:\n    case Ops.Atan:\n    case Ops.Sqrt:\n      {\n        return compileNumericExpression(expression, context);\n      }\n    case Ops.Case:\n      {\n        return compileCaseExpression(expression, context);\n      }\n    case Ops.Match:\n      {\n        return compileMatchExpression(expression, context);\n      }\n    case Ops.Interpolate:\n      {\n        return compileInterpolateExpression(expression, context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported operator ${operator}`);\n      }\n    // TODO: unimplemented\n    // Ops.Zoom\n    // Ops.Time\n    // Ops.Between\n    // Ops.In\n    // Ops.Array\n    // Ops.Color\n    // Ops.Band\n    // Ops.Palette\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAssertionExpression(expression, context) {\n  const type = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (type) {\n    case Ops.Coalesce:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value !== 'undefined' && value !== null) {\n              return value;\n            }\n          }\n          throw new Error('Expected one of the values to be non-null');\n        };\n      }\n    case Ops.Number:\n    case Ops.String:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            const value = args[i](context);\n            if (typeof value === type) {\n              return value;\n            }\n          }\n          throw new Error(`Expected one of the values to be a ${type}`);\n        };\n      }\n    default:\n      {\n        throw new Error(`Unsupported assertion operator ${type}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileAccessorExpression(expression, context) {\n  const nameExpression = /** @type {LiteralExpression} */expression.args[0];\n  const name = /** @type {string} */nameExpression.value;\n  switch (expression.operator) {\n    case Ops.Get:\n      {\n        return context => context.properties[name];\n      }\n    case Ops.Var:\n      {\n        return context => context.variables[name];\n      }\n    default:\n      {\n        throw new Error(`Unsupported accessor operator ${expression.operator}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileComparisonExpression(expression, context) {\n  const op = expression.operator;\n  const left = compileExpression(expression.args[0], context);\n  const right = compileExpression(expression.args[1], context);\n  switch (op) {\n    case Ops.Equal:\n      {\n        return context => left(context) === right(context);\n      }\n    case Ops.NotEqual:\n      {\n        return context => left(context) !== right(context);\n      }\n    case Ops.LessThan:\n      {\n        return context => left(context) < right(context);\n      }\n    case Ops.LessThanOrEqualTo:\n      {\n        return context => left(context) <= right(context);\n      }\n    case Ops.GreaterThan:\n      {\n        return context => left(context) > right(context);\n      }\n    case Ops.GreaterThanOrEqualTo:\n      {\n        return context => left(context) >= right(context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported comparison operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {BooleanEvaluator} The evaluator function.\n */\nfunction compileLogicalExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Any:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (args[i](context)) {\n              return true;\n            }\n          }\n          return false;\n        };\n      }\n    case Ops.All:\n      {\n        return context => {\n          for (let i = 0; i < length; ++i) {\n            if (!args[i](context)) {\n              return false;\n            }\n          }\n          return true;\n        };\n      }\n    case Ops.Not:\n      {\n        return context => !args[0](context);\n      }\n    default:\n      {\n        throw new Error(`Unsupported logical operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {NumberEvaluator} The evaluator function.\n */\nfunction compileNumericExpression(expression, context) {\n  const op = expression.operator;\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  switch (op) {\n    case Ops.Multiply:\n      {\n        return context => {\n          let value = 1;\n          for (let i = 0; i < length; ++i) {\n            value *= args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Divide:\n      {\n        return context => args[0](context) / args[1](context);\n      }\n    case Ops.Add:\n      {\n        return context => {\n          let value = 0;\n          for (let i = 0; i < length; ++i) {\n            value += args[i](context);\n          }\n          return value;\n        };\n      }\n    case Ops.Subtract:\n      {\n        return context => args[0](context) - args[1](context);\n      }\n    case Ops.Clamp:\n      {\n        return context => {\n          const value = args[0](context);\n          const min = args[1](context);\n          if (value < min) {\n            return min;\n          }\n          const max = args[2](context);\n          if (value > max) {\n            return max;\n          }\n          return value;\n        };\n      }\n    case Ops.Mod:\n      {\n        return context => args[0](context) % args[1](context);\n      }\n    case Ops.Pow:\n      {\n        return context => Math.pow(args[0](context), args[1](context));\n      }\n    case Ops.Abs:\n      {\n        return context => Math.abs(args[0](context));\n      }\n    case Ops.Floor:\n      {\n        return context => Math.floor(args[0](context));\n      }\n    case Ops.Ceil:\n      {\n        return context => Math.ceil(args[0](context));\n      }\n    case Ops.Round:\n      {\n        return context => Math.round(args[0](context));\n      }\n    case Ops.Sin:\n      {\n        return context => Math.sin(args[0](context));\n      }\n    case Ops.Cos:\n      {\n        return context => Math.cos(args[0](context));\n      }\n    case Ops.Atan:\n      {\n        if (length === 2) {\n          return context => Math.atan2(args[0](context), args[1](context));\n        }\n        return context => Math.atan(args[0](context));\n      }\n    case Ops.Sqrt:\n      {\n        return context => Math.sqrt(args[0](context));\n      }\n    default:\n      {\n        throw new Error(`Unsupported numeric operator ${op}`);\n      }\n  }\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileCaseExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    for (let i = 0; i < length - 1; i += 2) {\n      const condition = args[i](context);\n      if (condition) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileMatchExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const value = args[0](context);\n    for (let i = 1; i < length; i += 2) {\n      if (value === args[i](context)) {\n        return args[i + 1](context);\n      }\n    }\n    return args[length - 1](context);\n  };\n}\n\n/**\n * @param {import('./expression.js').CallExpression} expression The call expression.\n * @param {import('./expression.js').ParsingContext} context The parsing context.\n * @return {ExpressionEvaluator} The evaluator function.\n */\nfunction compileInterpolateExpression(expression, context) {\n  const length = expression.args.length;\n  const args = new Array(length);\n  for (let i = 0; i < length; ++i) {\n    args[i] = compileExpression(expression.args[i], context);\n  }\n  return context => {\n    const base = args[0](context);\n    const value = args[1](context);\n    let previousInput;\n    let previousOutput;\n    for (let i = 2; i < length; i += 2) {\n      const input = args[i](context);\n      let output = args[i + 1](context);\n      const isColor = Array.isArray(output);\n      if (isColor) {\n        output = withAlpha(output);\n      }\n      if (input >= value) {\n        if (i === 2) {\n          return output;\n        }\n        if (isColor) {\n          return interpolateColor(base, value, previousInput, previousOutput, input, output);\n        }\n        return interpolateNumber(base, value, previousInput, previousOutput, input, output);\n      }\n      previousInput = input;\n      previousOutput = output;\n    }\n    return previousOutput;\n  };\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {number} output1 The first output value.\n * @param {number} input2 The second input value.\n * @param {number} output2 The second output value.\n * @return {number} The interpolated value.\n */\nfunction interpolateNumber(base, value, input1, output1, input2, output2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return output1;\n  }\n  const along = value - input1;\n  const factor = base === 1 ? along / delta : (Math.pow(base, along) - 1) / (Math.pow(base, delta) - 1);\n  return output1 + factor * (output2 - output1);\n}\n\n/**\n * @param {number} base The base.\n * @param {number} value The value.\n * @param {number} input1 The first input value.\n * @param {import('../color.js').Color} rgba1 The first output value.\n * @param {number} input2 The second input value.\n * @param {import('../color.js').Color} rgba2 The second output value.\n * @return {import('../color.js').Color} The interpolated color.\n */\nfunction interpolateColor(base, value, input1, rgba1, input2, rgba2) {\n  const delta = input2 - input1;\n  if (delta === 0) {\n    return rgba1;\n  }\n  const lcha1 = rgbaToLcha(rgba1);\n  const lcha2 = rgbaToLcha(rgba2);\n  let deltaHue = lcha2[2] - lcha1[2];\n  if (deltaHue > 180) {\n    deltaHue -= 360;\n  } else if (deltaHue < -180) {\n    deltaHue += 360;\n  }\n  const lcha = [interpolateNumber(base, value, input1, lcha1[0], input2, lcha2[0]), interpolateNumber(base, value, input1, lcha1[1], input2, lcha2[1]), lcha1[2] + interpolateNumber(base, value, input1, 0, input2, deltaHue), interpolateNumber(base, value, input1, rgba1[3], input2, rgba2[3])];\n  return normalize(lchaToRgba(lcha));\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}